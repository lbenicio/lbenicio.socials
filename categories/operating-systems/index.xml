<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Operating-Systems on Leonardo Benicio</title><link>https://lbenicio.dev/categories/operating-systems/</link><description>Recent content in Operating-Systems on Leonardo Benicio</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 19 May 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://lbenicio.dev/categories/operating-systems/index.xml" rel="self" type="application/rss+xml"/><item><title>Virtual Memory and Page Tables: How Modern Systems Manage Memory</title><link>https://lbenicio.dev/blog/virtual-memory-and-page-tables-how-modern-systems-manage-memory/</link><pubDate>Thu, 19 May 2022 00:00:00 +0000</pubDate><guid>https://lbenicio.dev/blog/virtual-memory-and-page-tables-how-modern-systems-manage-memory/</guid><description>&lt;p&gt;Every process believes it has exclusive access to a vast, contiguous memory space. This elegant illusion—virtual memory—is one of the most important abstractions in computing. Behind it lies a sophisticated system of page tables, TLBs, and hardware-software cooperation that enables memory isolation, efficient sharing, and seemingly infinite memory. Let&amp;rsquo;s explore how it all works.&lt;/p&gt;
&lt;h2 id="1-the-problem-why-virtual-memory"&gt;1. The Problem: Why Virtual Memory?&lt;/h2&gt;
&lt;p&gt;Before virtual memory, programs used physical addresses directly. This created serious problems.&lt;/p&gt;</description></item><item><title>System Calls: The Gateway Between User Space and Kernel</title><link>https://lbenicio.dev/blog/system-calls-the-gateway-between-user-space-and-kernel/</link><pubDate>Sun, 18 Apr 2021 00:00:00 +0000</pubDate><guid>https://lbenicio.dev/blog/system-calls-the-gateway-between-user-space-and-kernel/</guid><description>&lt;p&gt;Every time your program opens a file, allocates memory, or sends a network packet, it crosses an invisible boundary. User programs cannot directly access hardware or kernel data structures—they must ask the operating system to do it for them through system calls. Understanding this interface is fundamental to systems programming and helps explain performance characteristics, security boundaries, and the design of operating systems themselves.&lt;/p&gt;
&lt;h2 id="1-the-user-kernel-boundary"&gt;1. The User-Kernel Boundary&lt;/h2&gt;
&lt;p&gt;Modern operating systems divide the world into two privilege levels.&lt;/p&gt;</description></item></channel></rss>