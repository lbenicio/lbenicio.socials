<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Operating-Systems on Leonardo Benicio</title><link>https://lbenicio.dev/tags/operating-systems/</link><description>Recent content in Operating-Systems on Leonardo Benicio</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 19 May 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://lbenicio.dev/tags/operating-systems/index.xml" rel="self" type="application/rss+xml"/><item><title>Virtual Memory and Page Tables: How Modern Systems Manage Memory</title><link>https://lbenicio.dev/blog/virtual-memory-and-page-tables-how-modern-systems-manage-memory/</link><pubDate>Thu, 19 May 2022 00:00:00 +0000</pubDate><guid>https://lbenicio.dev/blog/virtual-memory-and-page-tables-how-modern-systems-manage-memory/</guid><description>&lt;p&gt;Every process believes it has exclusive access to a vast, contiguous memory space. This elegant illusion—virtual memory—is one of the most important abstractions in computing. Behind it lies a sophisticated system of page tables, TLBs, and hardware-software cooperation that enables memory isolation, efficient sharing, and seemingly infinite memory. Let&amp;rsquo;s explore how it all works.&lt;/p&gt;
&lt;h2 id="1-the-problem-why-virtual-memory"&gt;1. The Problem: Why Virtual Memory?&lt;/h2&gt;
&lt;p&gt;Before virtual memory, programs used physical addresses directly. This created serious problems.&lt;/p&gt;</description></item><item><title>Process Scheduling and Context Switching: How Operating Systems Share the CPU</title><link>https://lbenicio.dev/blog/process-scheduling-and-context-switching-how-operating-systems-share-the-cpu/</link><pubDate>Wed, 18 May 2022 00:00:00 +0000</pubDate><guid>https://lbenicio.dev/blog/process-scheduling-and-context-switching-how-operating-systems-share-the-cpu/</guid><description>&lt;p&gt;A single CPU core can only execute one instruction stream at a time, yet modern systems run hundreds of processes simultaneously. This illusion of parallelism requires the operating system to rapidly switch between processes, giving each a slice of CPU time. The scheduler—the component that decides who runs next—profoundly affects system responsiveness, throughput, and fairness. Understanding scheduling reveals why your interactive applications feel smooth or sluggish and why some workloads perform better than others.&lt;/p&gt;</description></item><item><title>Virtual Memory and Page Tables: How Operating Systems Manage Memory</title><link>https://lbenicio.dev/blog/virtual-memory-and-page-tables-how-operating-systems-manage-memory/</link><pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate><guid>https://lbenicio.dev/blog/virtual-memory-and-page-tables-how-operating-systems-manage-memory/</guid><description>&lt;p&gt;Every process believes it has the entire machine to itself. It sees a vast, contiguous address space starting from zero, completely isolated from other processes. This illusion is virtual memory—one of the most important abstractions in computing. Understanding how operating systems and hardware collaborate to maintain this illusion reveals fundamental insights about performance, security, and system design.&lt;/p&gt;
&lt;h2 id="1-the-need-for-virtual-memory"&gt;1. The Need for Virtual Memory&lt;/h2&gt;
&lt;p&gt;Before virtual memory, programming was a constant juggling act.&lt;/p&gt;</description></item><item><title>System Calls: The Gateway Between User Space and Kernel</title><link>https://lbenicio.dev/blog/system-calls-the-gateway-between-user-space-and-kernel/</link><pubDate>Sun, 18 Apr 2021 00:00:00 +0000</pubDate><guid>https://lbenicio.dev/blog/system-calls-the-gateway-between-user-space-and-kernel/</guid><description>&lt;p&gt;Every time your program opens a file, allocates memory, or sends a network packet, it crosses an invisible boundary. User programs cannot directly access hardware or kernel data structures—they must ask the operating system to do it for them through system calls. Understanding this interface is fundamental to systems programming and helps explain performance characteristics, security boundaries, and the design of operating systems themselves.&lt;/p&gt;
&lt;h2 id="1-the-user-kernel-boundary"&gt;1. The User-Kernel Boundary&lt;/h2&gt;
&lt;p&gt;Modern operating systems divide the world into two privilege levels.&lt;/p&gt;</description></item><item><title>Modern Operating Systems (4th ed.)</title><link>https://lbenicio.dev/reading/modern-operating-systems-4th-ed./</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lbenicio.dev/reading/modern-operating-systems-4th-ed./</guid><description>&lt;h2 id="a-comprehensive-os-textbook-covering-processes-memory-management-file-systems-and-security"&gt;A comprehensive OS textbook covering processes, memory management, file systems, and security&lt;/h2&gt;
&lt;p&gt;A comprehensive OS textbook covering processes, memory management, file systems, and security.&lt;/p&gt;</description></item><item><title>Operating System Concepts (9th ed.)</title><link>https://lbenicio.dev/reading/operating-system-concepts-9th-ed./</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lbenicio.dev/reading/operating-system-concepts-9th-ed./</guid><description>&lt;p&gt;Foundations of operating systems including processes, threads, scheduling, memory, and file systems.&lt;/p&gt;</description></item><item><title>Operating Systems: Three Easy Pieces</title><link>https://lbenicio.dev/reading/operating-systems-three-easy-pieces/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lbenicio.dev/reading/operating-systems-three-easy-pieces/</guid><description>&lt;p&gt;A free, modular OS textbook with hands-on projects and clear explanations.&lt;/p&gt;</description></item></channel></rss>