<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Databases on Leonardo Benicio</title><link>https://lbenicio.dev/tags/databases/</link><description>Recent content in Databases on Leonardo Benicio</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sun, 21 Dec 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://lbenicio.dev/tags/databases/index.xml" rel="self" type="application/rss+xml"/><item><title>Database Internals: Storage Engines, Transactions, and Recovery</title><link>https://lbenicio.dev/blog/database-internals-storage-engines-transactions-and-recovery/</link><pubDate>Sun, 21 Dec 2025 00:00:00 +0000</pubDate><guid>https://lbenicio.dev/blog/database-internals-storage-engines-transactions-and-recovery/</guid><description>&lt;p&gt;Databases are much more than SQL parsers and client libraries — their core is a storage engine that durably stores and efficiently retrieves data while preserving the guarantees applications depend upon. This article unpacks how modern databases manage on-disk data structures, coordinate concurrent access, provide transactional semantics, and recover from crashes. We&amp;rsquo;ll look at B-trees and LSM-trees, the write-ahead log, MVCC and isolation levels, recovery algorithms, and practical tuning advice for real-world systems.&lt;/p&gt;</description></item><item><title>Inside Vector Databases: Building Retrieval-Augmented Systems that Scale</title><link>https://lbenicio.dev/blog/inside-vector-databases-building-retrieval-augmented-systems-that-scale/</link><pubDate>Sun, 26 Oct 2025 00:00:00 +0000</pubDate><guid>https://lbenicio.dev/blog/inside-vector-databases-building-retrieval-augmented-systems-that-scale/</guid><description>&lt;p&gt;Vector search used to be a research curiosity. Today it sits in the critical path of customer support bots, developer copilots, fraud monitors, and every product marketing team experimenting with &amp;ldquo;retrieval-augmented&amp;rdquo; workflows. The excitement is deserved, but so is the sober engineering required to keep these systems accurate and available. Building a production vector database is more than storing tensors and calling cosine similarity. It demands a full stack of ingestion, indexing, storage management, failure handling, evaluation, and a constant feedback loop with the language models that consume those results.&lt;/p&gt;</description></item><item><title>Learned Indexes: When Models Replace B‑Trees</title><link>https://lbenicio.dev/blog/learned-indexes-when-models-replace-btrees/</link><pubDate>Sat, 04 Oct 2025 10:00:00 +0000</pubDate><guid>https://lbenicio.dev/blog/learned-indexes-when-models-replace-btrees/</guid><description>&lt;p&gt;If you’ve spent a career trusting B‑trees and hash tables, the idea of using a machine‑learned model as an index can feel like swapping a torque wrench for a Ouija board. But learned indexes aren’t a gimmick. They exploit a simple observation: real data isn’t uniformly random. It has shape—monotonic keys, skewed distributions, natural clusters—and a model can learn that shape to predict where a key lives in a sorted array. The payoff is smaller indexes, fewer cache misses, and—sometimes—dramatically faster lookups.&lt;/p&gt;</description></item><item><title>Write-Ahead Logging: The Unsung Hero of Database Durability</title><link>https://lbenicio.dev/blog/write-ahead-logging-the-unsung-hero-of-database-durability/</link><pubDate>Tue, 10 Sep 2024 00:00:00 +0000</pubDate><guid>https://lbenicio.dev/blog/write-ahead-logging-the-unsung-hero-of-database-durability/</guid><description>&lt;p&gt;Every database makes a promise: your committed data will survive crashes, power failures, and hardware hiccups. This promise—durability—seems simple until you consider the physics. Disks are slow. Memory is volatile. Writes can be reordered. Yet somehow, databases deliver both durability and performance. The secret weapon? Write-ahead logging.&lt;/p&gt;
&lt;h2 id="1-the-durability-problem"&gt;1. The Durability Problem&lt;/h2&gt;
&lt;p&gt;Consider what happens when you execute &lt;code&gt;UPDATE accounts SET balance = balance - 100 WHERE id = 42&lt;/code&gt;. The database must:&lt;/p&gt;</description></item><item><title>Designing CRDT-Powered Collaboration Platforms that Stay Consistent</title><link>https://lbenicio.dev/blog/designing-crdt-powered-collaboration-platforms-that-stay-consistent/</link><pubDate>Wed, 17 Aug 2022 00:00:00 +0000</pubDate><guid>https://lbenicio.dev/blog/designing-crdt-powered-collaboration-platforms-that-stay-consistent/</guid><description>&lt;p&gt;Real-time collaboration has shifted from a feature to a baseline expectation. Teams sketch ideas in shared whiteboards, edit code together, and annotate product specs while sitting on unreliable networks. Delivering that experience demands more than WebSockets and optimistic UI code. The hard part is consistency: making sure each participant converges on the same state despite offline edits, concurrent operations, and shaky connectivity. Conflict-free replicated data types (CRDTs) emerged as the workhorse that keeps these experiences coherent.&lt;/p&gt;</description></item><item><title>B-Trees and LSM-Trees: The Foundations of Modern Storage Engines</title><link>https://lbenicio.dev/blog/b-trees-and-lsm-trees-the-foundations-of-modern-storage-engines/</link><pubDate>Wed, 14 Jul 2021 00:00:00 +0000</pubDate><guid>https://lbenicio.dev/blog/b-trees-and-lsm-trees-the-foundations-of-modern-storage-engines/</guid><description>&lt;p&gt;Every database faces the same fundamental challenge: how do you organize data on disk so that both reads and writes are fast? Two data structures have emerged as the dominant answers—B-Trees and LSM-Trees. Understanding their trade-offs is essential for anyone building or operating data-intensive systems. This post explores both in depth, from their internal mechanics to their real-world implementations.&lt;/p&gt;
&lt;h2 id="1-the-storage-engine-problem"&gt;1. The Storage Engine Problem&lt;/h2&gt;
&lt;p&gt;Before diving into specific data structures, let&amp;rsquo;s understand what we&amp;rsquo;re optimizing for.&lt;/p&gt;</description></item><item><title>Safe Rollback Strategies for Distributed Databases</title><link>https://lbenicio.dev/blog/safe-rollback-strategies-for-distributed-databases/</link><pubDate>Sun, 08 Nov 2020 00:00:00 +0000</pubDate><guid>https://lbenicio.dev/blog/safe-rollback-strategies-for-distributed-databases/</guid><description>&lt;p&gt;Rollbacks are the fire escapes of distributed databases. We hope never to use them, but when outages, migrations, or bad deployments hit, a well-practiced rollback can save hours of business downtime and piles of customer tickets. Unfortunately, many organizations treat rollback planning as an afterthought—&amp;ldquo;we&amp;rsquo;ll just restore from backup&amp;rdquo;—only to discover data drift, cascading failures, and angry stakeholders when the time comes. This article lays out a disciplined approach to rollback strategies tailored for modern distributed databases (PostgreSQL clusters, cloud-native NoSQL, sharded NewSQL, event-sourced systems) where consistency, latency, and regulatory obligations collide.&lt;/p&gt;</description></item><item><title>Consistent Hashing: Distributing Data Across Dynamic Clusters</title><link>https://lbenicio.dev/blog/consistent-hashing-distributing-data-across-dynamic-clusters/</link><pubDate>Sat, 28 Mar 2020 00:00:00 +0000</pubDate><guid>https://lbenicio.dev/blog/consistent-hashing-distributing-data-across-dynamic-clusters/</guid><description>&lt;p&gt;When you add a server to your distributed cache, what happens to all the cached data? With naive hashing, almost everything moves—a catastrophic reshuffling that defeats the purpose of caching. Consistent hashing solves this elegantly: only K/N keys need to move, where K is total keys and N is the number of servers. This simple idea underpins some of the most scalable systems ever built. Let&amp;rsquo;s explore how it works and why it matters.&lt;/p&gt;</description></item><item><title>Tuning the Dial: Adaptive Consistency at Planet Scale</title><link>https://lbenicio.dev/blog/tuning-the-dial-adaptive-consistency-at-planet-scale/</link><pubDate>Wed, 11 Mar 2020 14:05:00 +0000</pubDate><guid>https://lbenicio.dev/blog/tuning-the-dial-adaptive-consistency-at-planet-scale/</guid><description>&lt;p&gt;At 2:17 a.m. UTC, a partner bank in Singapore called our incident bridge. A fund transfer appeared twice in their ledger. The culprit: a replication lag spike between Singapore and Frankfurt had stretched past our standard safety buffers. Historically we would have halted writes across the fleet, cutting availability to protect consistency. Instead, our adaptive consistency layer dialed a region-specific policy: Singapore moved from &amp;ldquo;read-after-write&amp;rdquo; to &amp;ldquo;read-your-writes&amp;rdquo; guarantees, while Frankfurt raised its commit quorum. The double posting self-corrected before social media noticed. No downtime, no irreversible loss—just a story about how we learned to treat consistency as a spectrum rather than a binary.&lt;/p&gt;</description></item><item><title>Database System Concepts (7th ed.)</title><link>https://lbenicio.dev/reading/database-system-concepts-7th-ed./</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lbenicio.dev/reading/database-system-concepts-7th-ed./</guid><description>&lt;p&gt;Foundational text on database design, SQL, normalization, transactions, and architectures.&lt;/p&gt;</description></item><item><title>Database System Concepts (7th ed.)</title><link>https://lbenicio.dev/reading/database-system-concepts-7th-ed./</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lbenicio.dev/reading/database-system-concepts-7th-ed./</guid><description>&lt;p&gt;Foundational text on database design, SQL, transactions, and architectures.&lt;/p&gt;</description></item><item><title>Principles of Database and Knowledge-Base Systems</title><link>https://lbenicio.dev/reading/principles-of-database-and-knowledge-base-systems/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lbenicio.dev/reading/principles-of-database-and-knowledge-base-systems/</guid><description>&lt;p&gt;Foundational theory for databases and knowledge-base systems.&lt;/p&gt;</description></item></channel></rss>