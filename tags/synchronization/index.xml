<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Synchronization on Leonardo Benicio</title><link>https://lbenicio.dev/tags/synchronization/</link><description>Recent content in Synchronization on Leonardo Benicio</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Fri, 15 Mar 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://lbenicio.dev/tags/synchronization/index.xml" rel="self" type="application/rss+xml"/><item><title>Concurrency Primitives and Synchronization: From Spinlocks to Lock-Free Data Structures</title><link>https://lbenicio.dev/blog/concurrency-primitives-and-synchronization-from-spinlocks-to-lock-free-data-structures/</link><pubDate>Fri, 15 Mar 2024 00:00:00 +0000</pubDate><guid>https://lbenicio.dev/blog/concurrency-primitives-and-synchronization-from-spinlocks-to-lock-free-data-structures/</guid><description>&lt;p&gt;Concurrent programming transforms sequential code into parallel execution, unlocking the power of modern multicore processors. But with parallelism comes the challenge of coordinating access to shared resources. Race conditions lurk in code that appears correct, and subtle bugs emerge only under specific timing conditions. Understanding synchronization primitives from the hardware level up through high-level abstractions provides the foundation for writing correct, efficient concurrent programs.&lt;/p&gt;
&lt;h2 id="1-the-concurrency-challenge"&gt;1. The Concurrency Challenge&lt;/h2&gt;
&lt;p&gt;Why synchronization matters and what problems it solves.&lt;/p&gt;</description></item></channel></rss>